<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shio</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-25T14:23:37.554Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chenyang Wan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/25/Python%20Handbook/"/>
    <id>http://example.com/2023/09/25/Python%20Handbook/</id>
    <published>2023-09-25T13:47:36.345Z</published>
    <updated>2023-09-25T14:23:37.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="file-io">File I/O</h2><ul><li>将一个txt文件中的矩阵读出/将一个矩阵写入txt文件中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_to_matrix</span>(<span class="params">path</span>):</span><br><span class="line">    mat = np.loadtxt(path, dtype=np.int32, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    mat = np.array(mat, dtype=np.uint8)</span><br><span class="line">    <span class="keyword">return</span> mat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_to_file</span>(<span class="params">mat, path</span>):</span><br><span class="line">    np.savetxt(path, np.c_[mat], fmt=<span class="string">&#x27;%d&#x27;</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="matrix">Matrix</h2><ul><li>将矩阵展开成为一维数组。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat = mat.ravel() <span class="comment">#横向</span></span><br><span class="line"></span><br><span class="line">mat = mat.ravel(order=<span class="string">&#x27;F&#x27;</span>) <span class="comment">#纵向</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;file-io&quot;&gt;File I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将一个txt文件中的矩阵读出/将一个矩阵写入txt文件中。
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;file_to_matrix&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;path&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat = np.loadtxt(path, dtype=np.int32, delimiter=&lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat = np.array(mat, dtype=np.uint8)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;matrix_to_file&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;mat, path&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    np.savetxt(path, np.c_[mat], fmt=&lt;span class=&quot;string&quot;&gt;&amp;#x27;%d&amp;#x27;&lt;/span&gt;, delimiter=&lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;matrix&quot;&gt;Matrix&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将矩阵展开成为一维数组。 &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mat = mat.ravel() &lt;span class=&quot;comment&quot;&gt;#横向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mat = mat.ravel(order=&lt;span class=&quot;string&quot;&gt;&amp;#x27;F&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;#纵向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/24/Articulated%20Robots%20Lec1/"/>
    <id>http://example.com/2023/09/24/Articulated%20Robots%20Lec1/</id>
    <published>2023-09-24T07:19:58.405Z</published>
    <updated>2023-09-24T08:00:53.203Z</updated>
    
    <content type="html"><![CDATA[<hr /><hr /><h2 id="intro">Intro</h2><ul><li><strong>Mechanism</strong>: a system of two or more linked machineparts with kinetic parts.<ul><li>serially-connected open chain/close chain</li></ul></li><li><strong>Kinetic pairs</strong>: the moveable contact between twolinked machine pairs (Spot, Line, Surface).<ul><li>by pressure of contacts:<ul><li>lower pairs - surface</li><li>higher pairs - spot and line <strong>Notion: most pairs in a robotare planar pairs.</strong></li></ul></li></ul></li></ul><h2 id="degree-of-freedom">Degree of Freedom</h2><ul><li>a particle: <span class="math inline">\(DoF=3\)</span></li><li>a rigid body: <span class="math inline">\(DoF=6\)</span></li><li>a robot: <span class="math inline">\(DoF\)</span> depends...</li></ul><h3 id="dof-of-planar-mechanisms">DoF of Planar Mechanisms</h3><p>No. of movable parts: <span class="math inline">\(n=N-1\)</span> (Nis the number of pairs) No. of lower pairs: <spanclass="math inline">\(L\)</span> (brings <spanclass="math inline">\(2L\)</span> constraints) No. of higher pairs:<span class="math inline">\(H\)</span> (brings <spanclass="math inline">\(H\)</span> constraints)</p><p>total <span class="math inline">\(DoF\)</span>: <spanclass="math inline">\(3n-2L-H\)</span></p><h2 id="robot-manipulators">Robot Manipulators</h2>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mechanism&lt;/strong&gt;: a system of two or more linked machine
parts with kinetic parts.
&lt;ul&gt;
&lt;li&gt;serially-connected open chain/close chain&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kinetic pairs&lt;/strong&gt;: the moveable contact between two
linked machine pairs (Spot, Line, Surface).
&lt;ul&gt;
&lt;li&gt;by pressure of contacts:
&lt;ul&gt;
&lt;li&gt;lower pairs - surface&lt;/li&gt;
&lt;li&gt;higher pairs - spot and line &lt;strong&gt;Notion: most pairs in a robot
are planar pairs.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;degree-of-freedom&quot;&gt;Degree of Freedom&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a particle: &lt;span class=&quot;math inline&quot;&gt;&#92;(DoF=3&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;a rigid body: &lt;span class=&quot;math inline&quot;&gt;&#92;(DoF=6&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;a robot: &lt;span class=&quot;math inline&quot;&gt;&#92;(DoF&#92;)&lt;/span&gt; depends...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;dof-of-planar-mechanisms&quot;&gt;DoF of Planar Mechanisms&lt;/h3&gt;
&lt;p&gt;No. of movable parts: &lt;span class=&quot;math inline&quot;&gt;&#92;(n=N-1&#92;)&lt;/span&gt; (N
is the number of pairs) No. of lower pairs: &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; (brings &lt;span class=&quot;math inline&quot;&gt;&#92;(2L&#92;)&lt;/span&gt; constraints) No. of higher pairs:
&lt;span class=&quot;math inline&quot;&gt;&#92;(H&#92;)&lt;/span&gt; (brings &lt;span class=&quot;math inline&quot;&gt;&#92;(H&#92;)&lt;/span&gt; constraints)&lt;/p&gt;
&lt;p&gt;total &lt;span class=&quot;math inline&quot;&gt;&#92;(DoF&#92;)&lt;/span&gt;: &lt;span class=&quot;math inline&quot;&gt;&#92;(3n-2L-H&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;robot-manipulators&quot;&gt;Robot Manipulators&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>z变换</title>
    <link href="http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/"/>
    <id>http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/</id>
    <published>2023-09-20T08:29:31.493Z</published>
    <updated>2023-09-26T00:41:03.118Z</updated>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(z\)</span>变换（<spanclass="math inline">\(ZT\)</span>）<strong>是对离散序列进行的一种数学变换</strong>，常用于求线性时不变差分方程的解，它在离散系统中的地位如同拉普拉斯变换在连续系统中的地位。在自动控制系统中引入<spanclass="math inline">\(z\)</span>变换的主要目的是希望方便对于离散控制系统的研究。</p><h2 id="z变换"><span class="math inline">\(z\)</span>变换</h2><h3 id="z变换的定义"><spanclass="math inline">\(z\)</span>变换的定义</h3><p>设连续函数<spanclass="math inline">\(e(t)\)</span>是可拉氏变换的，则其拉氏变换定义为：<span class="math display">\[    E(s)=\mathscr{L}\left[ e(t) \right]=\int_{0}^{\infty}e(t)e^{-sT}dt\]</span> 对<spanclass="math inline">\(e(t)\)</span>的采样后的信号的表达式为： <spanclass="math display">\[e^*(t)=\sum_0^\infty e(nT)\delta(t-nT)\]</span> 采样信号<spanclass="math inline">\(e^*(t)\)</span>的拉氏变换为：</p><p><span class="math display">\[E^*(s)=\mathscr{L}[e^*(t)]=\sum_0^\infty e(nT)e^{-nsT}\]</span> 可以看到在<spanclass="math inline">\(s\)</span>域中的结果是比较复杂的，所以为了方便起见我们定义<spanclass="math inline">\(z=e^{sT}\)</span>，<spanclass="math inline">\(T\)</span>为采样周期，<spanclass="math inline">\(z\)</span>是在复数平面上定义的一个复变量，称为<spanclass="math inline">\(z\)</span>为变换算子。</p><p>采样信号<span class="math inline">\(e^*(t)\)</span>的<spanclass="math inline">\(z\)</span>变换为： <span class="math display">\[E(z)=\mathscr{Z}[e^*(t)]=\sum_0^\infty e(nT)e^{-snT}|_{s=\frac{1}{T}lnz}=\sum_0^\infty e(nT)z^{-n}\]</span>这个结果的形式是很简单的，实际上就是采样所得函数在每个采样点<spanclass="math inline">\(t=nT\)</span>时候的值乘上<spanclass="math inline">\(z^{-n}\)</span>，所以这个序列实际上表达出了每个特定的时刻的原函数取值。</p><h3 id="求z变换的方法">求<spanclass="math inline">\(z\)</span>变换的方法</h3><ol type="1"><li><p>级数求和 根据定义求<span class="math inline">\(z\)</span>变换：<span class="math display">\[F(z)=\mathscr{Z}[f^*(t)]=\sum_0^\infty f(nT)e^{-snT}|_{s=\frac{1}{T}lnz}=\sum_0^\infty f(nT)z^{-n}\]</span> 我们对于连续信号<spanclass="math inline">\(f(t)\)</span>只需要将其在采样时间<spanclass="math inline">\(t=nT\)</span>的时候的取值与对应的<spanclass="math inline">\(z^{-n}\)</span>相乘然后求和即可。</p></li><li><p>部分分式展开 这种方法主要用于对<spanclass="math inline">\(F(s)\)</span>进行变换。也就是说先求出已知的连续时间函数<spanclass="math inline">\(f(x)\)</span>的拉氏变换<spanclass="math inline">\(F(s)\)</span>，再把这个拉氏变换的结果展开成部分分式之和的形式，使得每一个部分对应的分式能够对应简单的时间函数。然后可得对应部分分式之和的<spanclass="math inline">\(z\)</span>变换结果。</p></li></ol><p>注意：<span class="math inline">\(F(z)=\mathscr{Z}[f^*(t)] \neq\mathscr{Z}[f(t)]\)</span></p><p>对于拉氏变换的结果<spanclass="math inline">\(F(s)\)</span>，将其写为有理函数的形式： <spanclass="math display">\[                F(s)=\frac{P(s)}{Q(s)}=\frac{\sum_{i=0}^n(s-s_i)^r}{\sum_{j=0}^m(s-s_j)^r}=\]</span> 从而可以得到</p><ol start="3" type="1"><li>留数法</li></ol><ul><li><span class="math inline">\(f(t)\)</span>的<spanclass="math inline">\(Laplace\)</span>变换是一个有理分式，<spanclass="math inline">\(p_i\)</span>为其极点</li><li><spanclass="math inline">\(F(s)\)</span>分母的阶次比分子的阶次高2阶以上</li></ul><p>此时<spanclass="math inline">\(z\)</span>变换的闭合解析形式表示为：<spanclass="math inline">\(F(z)=\hat{F}(z)+\beta\)</span> 其中： <spanclass="math display">\[    \hat F(z)=\sum_{i=1}^{n}Res[F(p_i)\frac{1}{1-e^{-(s-p_i)T}}]\]</span> <span class="math display">\[\beta = \lim_{s \rightarrow \infty}sF(s) - \lim_{z \rightarrow\infty}\hat F(z)\]</span> <spanclass="math inline">\(\beta\)</span>的引入是为了保证初值相同。 ### <spanclass="math inline">\(z\)</span>变换的性质</p><ol type="1"><li><p>线性性质</p></li><li><p>初值定理 若<span class="math inline">\(\lim_{z \rightarrow\infty} F(z)\)</span>存在，则： <span class="math display">\[\lim_{k \rightarrow 0}f(kT)  = \lim_{z \rightarrow \infty}F(z)\]</span></p></li><li><p>终值定理 如果<spanclass="math inline">\(F(z)\)</span>满足下列条件之一：</p><ol type="1"><li><span class="math inline">\(F(z)\)</span>的所有极点在开单位圆内</li><li><spanclass="math inline">\(F(z)\)</span>至多只有一个在单位圆上的极点，且必须为1处的一阶极点那么： <span class="math display">\[\lim_{k \rightarrow \infty}f(kT)  = \lim_{z \rightarrow1}[(1-z^{-1})F(z)]\]</span></li></ol></li><li><p>复域微分定理 <span class="math display">\[\mathscr Z [tx(t)] = -Tz \frac{dX(z)}{dz}\]</span> <span class="math display">\[\mathscr Z [kx(t)] = -z \frac{dX(z)}{dz} \quad where \quad k =\frac{t}{T}\]</span></p></li><li><p>复位移定理 <span class="math display">\[\mathscr Z[e^{-\alpha T}x(t)]=\]</span></p></li></ol><h2 id="z反变换"><span class="math inline">\(z\)</span>反变换</h2><ul><li>相同的<span class="math inline">\(z\)</span>变换<spanclass="math inline">\(E(z)\)</span>对应于相同的采样函数<spanclass="math inline">\(e^*(t)\)</span>，但是不一定对应于相同的原连续函数<spanclass="math inline">\(e(t)\)</span>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换（&lt;span class=&quot;math inline&quot;&gt;&#92;(ZT&#92;)&lt;/span&gt;）&lt;strong&gt;是对离散序列进行的一种数学变换&lt;/strong&gt;，常用于求线性时不变差分方程的解，它在离散系统中的地位如同拉普拉斯变换在连续系统中的地位。在自动控制系统中引入&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换的主要目的是希望方便对于离散控制系统的研究。&lt;/p&gt;
&lt;h2 id=&quot;z变换&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换&lt;/h2&gt;
&lt;h3 id=&quot;z变换的定义&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换的定义&lt;/h3&gt;
&lt;p&gt;设连续函数&lt;span class=&quot;math inline&quot;&gt;&#92;(e(t)&#92;)&lt;/span&gt;是可拉氏变换的，则其拉氏变换定义为：
&lt;span class=&quot;math display&quot;&gt;&#92;[
    E(s)=&#92;mathscr{L}&#92;left[ e(t) &#92;right]=&#92;int_{0}^{&#92;infty}e(t)e^{-sT}dt
&#92;]&lt;/span&gt; 对&lt;span class=&quot;math inline&quot;&gt;&#92;(e(t)&#92;)&lt;/span&gt;的采样后的信号的表达式为： &lt;span class=&quot;math display&quot;&gt;&#92;[
e^*(t)=&#92;sum_0^&#92;infty e(nT)&#92;delta(t-nT)
&#92;]&lt;/span&gt; 采样信号&lt;span class=&quot;math inline&quot;&gt;&#92;(e^*(t)&#92;)&lt;/span&gt;的拉氏变换为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
E^*(s)=&#92;mathscr{L}[e^*(t)]=&#92;sum_0^&#92;infty e(nT)e^{-nsT}
&#92;]&lt;/span&gt; 可以看到在&lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;)&lt;/span&gt;域中的结果是比较复杂的，所以为了方便起见我们定义&lt;span class=&quot;math inline&quot;&gt;&#92;(z=e^{sT}&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;为采样周期，&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;是在复数平面上定义的一个复变量，称为&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;为变换算子。&lt;/p&gt;
&lt;p&gt;采样信号&lt;span class=&quot;math inline&quot;&gt;&#92;(e^*(t)&#92;)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换为： &lt;span class=&quot;math display&quot;&gt;&#92;[
E(z)=&#92;mathscr{Z}[e^*(t)]=&#92;sum_0^&#92;infty e(nT)e^{-snT}
|_{s=&#92;frac{1}{T}lnz}=&#92;sum_0^&#92;infty e(nT)z^{-n}
&#92;]&lt;/span&gt;
这个结果的形式是很简单的，实际上就是采样所得函数在每个采样点&lt;span class=&quot;math inline&quot;&gt;&#92;(t=nT&#92;)&lt;/span&gt;时候的值乘上&lt;span class=&quot;math inline&quot;&gt;&#92;(z^{-n}&#92;)&lt;/span&gt;，所以这个序列实际上表达出了每个特定的时刻的原函数取值。&lt;/p&gt;
&lt;h3 id=&quot;求z变换的方法&quot;&gt;求&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换的方法&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;级数求和 根据定义求&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换：
&lt;span class=&quot;math display&quot;&gt;&#92;[
F(z)=&#92;mathscr{Z}[f^*(t)]=&#92;sum_0^&#92;infty f(nT)e^{-snT}
|_{s=&#92;frac{1}{T}lnz}=&#92;sum_0^&#92;infty f(nT)z^{-n}
&#92;]&lt;/span&gt; 我们对于连续信号&lt;span class=&quot;math inline&quot;&gt;&#92;(f(t)&#92;)&lt;/span&gt;只需要将其在采样时间&lt;span class=&quot;math inline&quot;&gt;&#92;(t=nT&#92;)&lt;/span&gt;的时候的取值与对应的&lt;span class=&quot;math inline&quot;&gt;&#92;(z^{-n}&#92;)&lt;/span&gt;相乘然后求和即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部分分式展开 这种方法主要用于对&lt;span class=&quot;math inline&quot;&gt;&#92;(F(s)&#92;)&lt;/span&gt;进行变换。也就是说先求出已知的连续时间函数&lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt;的拉氏变换&lt;span class=&quot;math inline&quot;&gt;&#92;(F(s)&#92;)&lt;/span&gt;，再把这个拉氏变换的结果展开成部分分式之和的形式，使得每一个部分对应的分式能够对应简单的时间函数。然后可得对应部分分式之和的&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换结果。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;span class=&quot;math inline&quot;&gt;&#92;(F(z)=&#92;mathscr{Z}[f^*(t)] &#92;neq
&#92;mathscr{Z}[f(t)]&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于拉氏变换的结果&lt;span class=&quot;math inline&quot;&gt;&#92;(F(s)&#92;)&lt;/span&gt;，将其写为有理函数的形式： &lt;span class=&quot;math display&quot;&gt;&#92;[
                F(s)=&#92;frac{P(s)}{Q(s)}=&#92;frac{&#92;sum_{i=0}^n(s-s_i)^r}{&#92;sum_{j=0}^m(s-s_j)^r}=
&#92;]&lt;/span&gt; 从而可以得到&lt;/p&gt;</summary>
    
    
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec2 Stream II</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/</id>
    <published>2023-09-19T07:40:26.838Z</published>
    <updated>2023-09-19T07:41:26.636Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">
</summary>
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec0 Intro</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec0%20Intro/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec0%20Intro/</id>
    <published>2023-09-19T05:08:57.367Z</published>
    <updated>2023-09-23T06:41:46.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-types-and-structs">C++ Types and Structs</h2><h3 id="fundamental-types">Fundamental Types</h3><h3 id="dynamic-and-static-typing">Dynamic and Static typing</h3><p>C++ is a <strong>statically typed language.</strong></p><ul><li><code>statically typed</code>: Everything with a name (variables,functions, etc) is <strong>given a type before runtime.</strong>(C++)</li><li><code>dynamically typed</code>: Everything with a name (variables,functions, etc) is <strong>given a type at runtime</strong> based on thething’s current value. (Python)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CRASH during runtime, can’t divide a string</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_3</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">div_3(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile error: this code will never run</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div_3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">div_3</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Runtime</code>: Period when program is executing commands(after compilation, if compiled).</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;c-types-and-structs&quot;&gt;C++ Types and Structs&lt;/h2&gt;
&lt;h3 id=&quot;fundamental-types&quot;&gt;Fundamental Types&lt;/h3&gt;
&lt;h3 id=&quot;dynamic-and-static-typing&quot;&gt;Dynamic and Static typing&lt;/h3&gt;
&lt;p&gt;C++ is a &lt;strong&gt;statically typed language.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;statically typed&lt;/code&gt;: Everything with a name (variables,
functions, etc) is &lt;strong&gt;given a type before runtime.&lt;/strong&gt;
(C++)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamically typed&lt;/code&gt;: Everything with a name (variables,
functions, etc) is &lt;strong&gt;given a type at runtime&lt;/strong&gt; based on the
thing’s current value. (Python)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CRASH during runtime, can’t divide a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;div_3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;div_3(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Compile error: this code will never run&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;div_3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;div_3&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;: Period when program is executing commands
(after compilation, if compiled).&lt;/p&gt;
</summary>
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: ROS</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20ROS/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20ROS/</id>
    <published>2023-09-19T05:03:43.497Z</published>
    <updated>2023-09-19T05:10:56.652Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">
</summary>
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="ROS" scheme="http://example.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: Linux</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20Linux/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20Linux/</id>
    <published>2023-09-19T05:00:34.120Z</published>
    <updated>2023-09-19T05:10:42.512Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">
</summary>
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CS229: Lec1 Supervised Learning</title>
    <link href="http://example.com/2023/09/19/CS229%20Lec1/"/>
    <id>http://example.com/2023/09/19/CS229%20Lec1/</id>
    <published>2023-09-19T01:53:29.923Z</published>
    <updated>2023-09-19T05:10:29.943Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">
</summary>
    
    
    
    
    <category term="MachineLearning" scheme="http://example.com/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec1 Stream I</title>
    <link href="http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/"/>
    <id>http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/</id>
    <published>2023-09-18T12:08:45.236Z</published>
    <updated>2023-09-21T02:22:58.660Z</updated>
    
    <content type="html"><![CDATA[<p>3## Introduction to streams</p><p>Abstractly, a <strong>stream</strong> is a sequence of bytes that canbe accessed sequentially. Over time, a stream may produce or consumepotentially unlimited amounts of data. You can imagine stream to be a<strong>character buffer</strong> that automatically interacts with theexternal source. Streams automatically convert variables to a stringform that can be written into a buffer. And the opposite is a similarcase. A string stream is not connected to any external source.</p><h2 id="standard-streams">Standard streams</h2><ul><li><code>cin</code>: an <code>istream</code> object tied to thestandard input (typically the keyboard)</li><li><code>cout</code>: an <code>ostream</code> object tied to thestandard output (typically the monitor)</li><li><code>cerr</code>: an <code>ostream</code> object tied to thestandard error (typically the monitor), providing unbuffered output</li><li><code>clog</code>: an <code>ostream</code> object tied to thestandard error (typically the monitor), providing buffered output</li></ul><h2 id="output-streams">Output streams</h2><p>After you initializing an stream (empty, or initialized with a<code>const char*</code> or something else), the position starts at thebeginning of the "buffer". But after your stream insertion, the positionstarts at the end. Here is an example with the<code>std::ostringstream</code> :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// for cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  <span class="comment">// for ostringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ostringstream is a stream that writes to a string</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostringstream <span class="title">oss1</span><span class="params">(<span class="string">&quot; Hello world. &quot;</span>)</span></span>; <span class="comment">// initialize with string</span></span><br><span class="line">    std::cout &lt;&lt; oss1.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss2; <span class="comment">// initialize with no string</span></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; Nice 2 meet u. &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; See u tomorrow. &quot;</span> &lt;&lt; std::endl; <span class="comment">// append a string</span></span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world.</span><br><span class="line">Nice 2 meet u.</span><br><span class="line">Nice 2 meet u. See u tomorrow.</span><br></pre></td></tr></table></figure><h2 id="input-streams">Input streams</h2><p>Now we want to know the behavior of input streams. Take the<code>std::istringstream</code> as an example.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice to meet u 2. &quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="type">double</span> number;</span><br><span class="line"></span><br><span class="line">    iss &gt;&gt; word &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;word: &quot;</span> &lt;&lt; word &lt;&lt; std::endl; <span class="comment">// &quot;word: Nice&quot;</span></span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl; <span class="comment">// &quot;number: ?&quot;</span></span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 0</span><br></pre></td></tr></table></figure><p>In the example above, the variables read something from the<code>std::istringstream</code>. But clearly the <em>number</em> failedto read the value expected. Now we modify the <em>iss</em> a little.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice 2 meet u too. &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>And now the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 2</span><br></pre></td></tr></table></figure><h2 id="locate-and-set-the-position">Locate and set the position</h2><p>We use the method <code>tellp()</code> to get the position,<code>std::stream()</code> to create offset, and the<code>seekp()</code> to set a new position in the stream <code>ss</code>in the example below. These methods let you to manually set theposition, and most useful is the offset can be <strong>added</strong> topositions. But remember that <strong>the position can never be less than0</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    std::fpos pos = ss.<span class="built_in">tellp</span>() + std::<span class="built_in">streamoff</span>(<span class="number">3</span>); <span class="comment">// get position, and add 3</span></span><br><span class="line">    ss.<span class="built_in">seekp</span>(pos); <span class="comment">// set position</span></span><br></pre></td></tr></table></figure><h2 id="state-bits">State bits</h2><p>There four bits to indicate the state of the stream.</p><ol type="1"><li><code>Good bit</code>: Ready for read/write. Nothing unusual, onwhen <strong>other bits are off</strong>.</li><li><code>Fail bit</code>: Previous operation failed, all futureoperations <strong>frozen</strong>. Like:<ul><li>Type mismatch</li><li>File can't be opened</li><li>Seeking failed</li></ul></li><li><code>EOF bit</code>: Previous operation reached the end of thebuffer content. Nothing left.</li><li><code>Bad bit</code>: External error, likely irrecoverable. Couldnot move characters from external source (e.g. the file you are readingfrom is suddenly deleted).</li></ol><p><strong>Caution !!!</strong> - <code>Good</code> and<code>Fail</code> are not opposite, and <code>Good</code> and<code>Bad</code> are not opposite. - <code>Fail</code> and<code>EOF</code> are normally you will be checking. - You will rarelyuse <code>Good</code>.</p><p>Here is a function <code>printStreamState</code> to print the statebits of a stream.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStreamState</span><span class="params">(std::ostream &amp; os)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;good: &quot;</span> &lt;&lt; os.<span class="built_in">good</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail: &quot;</span> &lt;&lt; os.<span class="built_in">fail</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eof: &quot;</span> &lt;&lt; os.<span class="built_in">eof</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bad: &quot;</span> &lt;&lt; os.<span class="built_in">bad</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As a result, we can implement a complete version of the function<code>stringToInteger</code> with <strong>error-checking</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInteger</span><span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="comment">//passing by reference and never change it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">iss &gt;&gt; result;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> remain;</span><br><span class="line">iss &gt;&gt; remain;</span><br><span class="line"><span class="keyword">if</span> (!iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//make sure no characters left in the buffer</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, the <code>&gt;&gt;</code> operator returns the stream whichis converted to <code>!stream.fail()</code>. So we can have a veryhelpful shortcut from it:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iss &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) &#123; <span class="comment">//report error&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; ch)) &#123; <span class="comment">//report error&#125;</span></span><br></pre></td></tr></table></figure><p>So the error-checking part in the function<code>stringToInteger</code> can be rewriten as:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; result) || iss &gt;&gt; remain) </span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;3## Introduction to streams&lt;/p&gt;
&lt;p&gt;Abstractly, a &lt;strong&gt;stream&lt;/strong&gt; is a sequence of bytes that can
be accessed sequentially. Over time, a stream may produce or consume
potentially unlimited amounts of data. You can imagine stream to be a
&lt;strong&gt;character buffer&lt;/strong&gt; that automatically interacts with the
external source. Streams automatically convert variables to a string
form that can be written into a buffer. And the opposite is a similar
case. A string stream is not connected to any external source.&lt;/p&gt;
&lt;h2 id=&quot;standard-streams&quot;&gt;Standard streams&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cin&lt;/code&gt;: an &lt;code&gt;istream&lt;/code&gt; object tied to the
standard input (typically the keyboard)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the
standard output (typically the monitor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the
standard error (typically the monitor), providing unbuffered output&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the
standard error (typically the monitor), providing buffered output&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;output-streams&quot;&gt;Output streams&lt;/h2&gt;
&lt;p&gt;After you initializing an stream (empty, or initialized with a
&lt;code&gt;const char*&lt;/code&gt; or something else), the position starts at the
beginning of the &quot;buffer&quot;. But after your stream insertion, the position
starts at the end. Here is an example with the
&lt;code&gt;std::ostringstream&lt;/code&gt; :&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// for cout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;sstream&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// for ostringstream&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ostringstream is a stream that writes to a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;std::ostringstream &lt;span class=&quot;title&quot;&gt;oss1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot; Hello world. &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// initialize with string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss1.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::ostringstream oss2; &lt;span class=&quot;comment&quot;&gt;// initialize with no string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oss2 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; Nice 2 meet u. &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss2.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oss2 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; See u tomorrow. &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;comment&quot;&gt;// append a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss2.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And the output is:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Hello world.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nice 2 meet u.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nice 2 meet u. See u tomorrow.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;input-streams&quot;&gt;Input streams&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
</feed>
