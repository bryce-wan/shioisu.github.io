<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shio</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-25T14:23:37.554Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chenyang Wan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/25/Python%20Handbook/"/>
    <id>http://example.com/2023/09/25/Python%20Handbook/</id>
    <published>2023-09-25T13:47:36.345Z</published>
    <updated>2023-09-25T14:23:37.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="file-io">File I/O</h2><ul><li>将一个txt文件中的矩阵读出/将一个矩阵写入txt文件中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_to_matrix</span>(<span class="params">path</span>):</span><br><span class="line">    mat = np.loadtxt(path, dtype=np.int32, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    mat = np.array(mat, dtype=np.uint8)</span><br><span class="line">    <span class="keyword">return</span> mat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_to_file</span>(<span class="params">mat, path</span>):</span><br><span class="line">    np.savetxt(path, np.c_[mat], fmt=<span class="string">&#x27;%d&#x27;</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="matrix">Matrix</h2><ul><li>将矩阵展开成为一维数组。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat = mat.ravel() <span class="comment">#横向</span></span><br><span class="line"></span><br><span class="line">mat = mat.ravel(order=<span class="string">&#x27;F&#x27;</span>) <span class="comment">#纵向</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;file-io&quot;&gt;File I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将一个txt文件中的矩阵读出/将一个矩阵写入txt文件中。
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/24/Articulated%20Robots%20Lec1/"/>
    <id>http://example.com/2023/09/24/Articulated%20Robots%20Lec1/</id>
    <published>2023-09-24T07:19:58.405Z</published>
    <updated>2023-09-24T08:00:53.203Z</updated>
    
    <content type="html"><![CDATA[<hr /><hr /><h2 id="intro">Intro</h2><ul><li><strong>Mechanism</strong>: a system of two or more linked machineparts with kinetic parts.<ul><li>serially-connected open chain/close chain</li></ul></li><li><strong>Kinetic pairs</strong>: the moveable contact between twolinked machine pairs (Spot, Line, Surface).<ul><li>by pressure of contacts:<ul><li>lower pairs - surface</li><li>higher pairs - spot and line <strong>Notion: most pairs in a robotare planar pairs.</strong></li></ul></li></ul></li></ul><h2 id="degree-of-freedom">Degree of Freedom</h2><ul><li>a particle: <span class="math inline">\(DoF=3\)</span></li><li>a rigid body: <span class="math inline">\(DoF=6\)</span></li><li>a robot: <span class="math inline">\(DoF\)</span> depends...</li></ul><h3 id="dof-of-planar-mechanisms">DoF of Planar Mechanisms</h3><p>No. of movable parts: <span class="math inline">\(n=N-1\)</span> (Nis the number of pairs) No. of lower pairs: <spanclass="math inline">\(L\)</span> (brings <spanclass="math inline">\(2L\)</span> constraints) No. of higher pairs:<span class="math inline">\(H\)</span> (brings <spanclass="math inline">\(H\)</span> constraints)</p><p>total <span class="math inline">\(DoF\)</span>: <spanclass="math inline">\(3n-2L-H\)</span></p><h2 id="robot-manipulators">Robot Manipulators</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mechanism&lt;/strong&gt;: a system of two or more linked machine
parts with kinetic </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>z变换</title>
    <link href="http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/"/>
    <id>http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/</id>
    <published>2023-09-20T08:29:31.493Z</published>
    <updated>2023-09-26T00:41:03.118Z</updated>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(z\)</span>变换（<spanclass="math inline">\(ZT\)</span>）<strong>是对离散序列进行的一种数学变换</strong>，常用于求线性时不变差分方程的解，它在离散系统中的地位如同拉普拉斯变换在连续系统中的地位。在自动控制系统中引入<spanclass="math inline">\(z\)</span>变换的主要目的是希望方便对于离散控制系统的研究。</p><h2 id="z变换"><span class="math inline">\(z\)</span>变换</h2><h3 id="z变换的定义"><spanclass="math inline">\(z\)</span>变换的定义</h3><p>设连续函数<spanclass="math inline">\(e(t)\)</span>是可拉氏变换的，则其拉氏变换定义为：<span class="math display">\[    E(s)=\mathscr{L}\left[ e(t) \right]=\int_{0}^{\infty}e(t)e^{-sT}dt\]</span> 对<spanclass="math inline">\(e(t)\)</span>的采样后的信号的表达式为： <spanclass="math display">\[e^*(t)=\sum_0^\infty e(nT)\delta(t-nT)\]</span> 采样信号<spanclass="math inline">\(e^*(t)\)</span>的拉氏变换为：</p><p><span class="math display">\[E^*(s)=\mathscr{L}[e^*(t)]=\sum_0^\infty e(nT)e^{-nsT}\]</span> 可以看到在<spanclass="math inline">\(s\)</span>域中的结果是比较复杂的，所以为了方便起见我们定义<spanclass="math inline">\(z=e^{sT}\)</span>，<spanclass="math inline">\(T\)</span>为采样周期，<spanclass="math inline">\(z\)</span>是在复数平面上定义的一个复变量，称为<spanclass="math inline">\(z\)</span>为变换算子。</p><p>采样信号<span class="math inline">\(e^*(t)\)</span>的<spanclass="math inline">\(z\)</span>变换为： <span class="math display">\[E(z)=\mathscr{Z}[e^*(t)]=\sum_0^\infty e(nT)e^{-snT}|_{s=\frac{1}{T}lnz}=\sum_0^\infty e(nT)z^{-n}\]</span>这个结果的形式是很简单的，实际上就是采样所得函数在每个采样点<spanclass="math inline">\(t=nT\)</span>时候的值乘上<spanclass="math inline">\(z^{-n}\)</span>，所以这个序列实际上表达出了每个特定的时刻的原函数取值。</p><h3 id="求z变换的方法">求<spanclass="math inline">\(z\)</span>变换的方法</h3><ol type="1"><li><p>级数求和 根据定义求<span class="math inline">\(z\)</span>变换：<span class="math display">\[F(z)=\mathscr{Z}[f^*(t)]=\sum_0^\infty f(nT)e^{-snT}|_{s=\frac{1}{T}lnz}=\sum_0^\infty f(nT)z^{-n}\]</span> 我们对于连续信号<spanclass="math inline">\(f(t)\)</span>只需要将其在采样时间<spanclass="math inline">\(t=nT\)</span>的时候的取值与对应的<spanclass="math inline">\(z^{-n}\)</span>相乘然后求和即可。</p></li><li><p>部分分式展开 这种方法主要用于对<spanclass="math inline">\(F(s)\)</span>进行变换。也就是说先求出已知的连续时间函数<spanclass="math inline">\(f(x)\)</span>的拉氏变换<spanclass="math inline">\(F(s)\)</span>，再把这个拉氏变换的结果展开成部分分式之和的形式，使得每一个部分对应的分式能够对应简单的时间函数。然后可得对应部分分式之和的<spanclass="math inline">\(z\)</span>变换结果。</p></li></ol><p>注意：<span class="math inline">\(F(z)=\mathscr{Z}[f^*(t)] \neq\mathscr{Z}[f(t)]\)</span></p><p>对于拉氏变换的结果<spanclass="math inline">\(F(s)\)</span>，将其写为有理函数的形式： <spanclass="math display">\[                F(s)=\frac{P(s)}{Q(s)}=\frac{\sum_{i=0}^n(s-s_i)^r}{\sum_{j=0}^m(s-s_j)^r}=\]</span> 从而可以得到</p><ol start="3" type="1"><li>留数法</li></ol><ul><li><span class="math inline">\(f(t)\)</span>的<spanclass="math inline">\(Laplace\)</span>变换是一个有理分式，<spanclass="math inline">\(p_i\)</span>为其极点</li><li><spanclass="math inline">\(F(s)\)</span>分母的阶次比分子的阶次高2阶以上</li></ul><p>此时<spanclass="math inline">\(z\)</span>变换的闭合解析形式表示为：<spanclass="math inline">\(F(z)=\hat{F}(z)+\beta\)</span> 其中： <spanclass="math display">\[    \hat F(z)=\sum_{i=1}^{n}Res[F(p_i)\frac{1}{1-e^{-(s-p_i)T}}]\]</span> <span class="math display">\[\beta = \lim_{s \rightarrow \infty}sF(s) - \lim_{z \rightarrow\infty}\hat F(z)\]</span> <spanclass="math inline">\(\beta\)</span>的引入是为了保证初值相同。 ### <spanclass="math inline">\(z\)</span>变换的性质</p><ol type="1"><li><p>线性性质</p></li><li><p>初值定理 若<span class="math inline">\(\lim_{z \rightarrow\infty} F(z)\)</span>存在，则： <span class="math display">\[\lim_{k \rightarrow 0}f(kT)  = \lim_{z \rightarrow \infty}F(z)\]</span></p></li><li><p>终值定理 如果<spanclass="math inline">\(F(z)\)</span>满足下列条件之一：</p><ol type="1"><li><span class="math inline">\(F(z)\)</span>的所有极点在开单位圆内</li><li><spanclass="math inline">\(F(z)\)</span>至多只有一个在单位圆上的极点，且必须为1处的一阶极点那么： <span class="math display">\[\lim_{k \rightarrow \infty}f(kT)  = \lim_{z \rightarrow1}[(1-z^{-1})F(z)]\]</span></li></ol></li><li><p>复域微分定理 <span class="math display">\[\mathscr Z [tx(t)] = -Tz \frac{dX(z)}{dz}\]</span> <span class="math display">\[\mathscr Z [kx(t)] = -z \frac{dX(z)}{dz} \quad where \quad k =\frac{t}{T}\]</span></p></li><li><p>复位移定理 <span class="math display">\[\mathscr Z[e^{-\alpha T}x(t)]=\]</span></p></li></ol><h2 id="z反变换"><span class="math inline">\(z\)</span>反变换</h2><ul><li>相同的<span class="math inline">\(z\)</span>变换<spanclass="math inline">\(E(z)\)</span>对应于相同的采样函数<spanclass="math inline">\(e^*(t)\)</span>，但是不一定对应于相同的原连续函数<spanclass="math inline">\(e(t)\)</span>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;变换（&lt;span
class=&quot;math inline&quot;&gt;&#92;(ZT&#92;)&lt;/span&gt;）&lt;strong&gt;是对离散序列进行的一种数学变换&lt;/strong&gt;，常用于求线性时不变差分方程的解，它在离散系统</summary>
      
    
    
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec2 Stream II</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/</id>
    <published>2023-09-19T07:40:26.838Z</published>
    <updated>2023-09-19T07:41:26.636Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec0 Intro</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec0%20Intro/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec0%20Intro/</id>
    <published>2023-09-19T05:08:57.367Z</published>
    <updated>2023-09-23T06:41:46.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-types-and-structs">C++ Types and Structs</h2><h3 id="fundamental-types">Fundamental Types</h3><h3 id="dynamic-and-static-typing">Dynamic and Static typing</h3><p>C++ is a <strong>statically typed language.</strong></p><ul><li><code>statically typed</code>: Everything with a name (variables,functions, etc) is <strong>given a type before runtime.</strong>(C++)</li><li><code>dynamically typed</code>: Everything with a name (variables,functions, etc) is <strong>given a type at runtime</strong> based on thething’s current value. (Python)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CRASH during runtime, can’t divide a string</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_3</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">div_3(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile error: this code will never run</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div_3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">div_3</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Runtime</code>: Period when program is executing commands(after compilation, if compiled).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-types-and-structs&quot;&gt;C++ Types and Structs&lt;/h2&gt;
&lt;h3 id=&quot;fundamental-types&quot;&gt;Fundamental Types&lt;/h3&gt;
&lt;h3 id=&quot;dynamic-and-static-typin</summary>
      
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: ROS</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20ROS/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20ROS/</id>
    <published>2023-09-19T05:03:43.497Z</published>
    <updated>2023-09-19T05:10:56.652Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="ROS" scheme="http://example.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: Linux</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20Linux/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20Linux/</id>
    <published>2023-09-19T05:00:34.120Z</published>
    <updated>2023-09-19T05:10:42.512Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CS229: Lec1 Supervised Learning</title>
    <link href="http://example.com/2023/09/19/CS229%20Lec1/"/>
    <id>http://example.com/2023/09/19/CS229%20Lec1/</id>
    <published>2023-09-19T01:53:29.923Z</published>
    <updated>2023-09-19T05:10:29.943Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="MachineLearning" scheme="http://example.com/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec1 Stream I</title>
    <link href="http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/"/>
    <id>http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/</id>
    <published>2023-09-18T12:08:45.236Z</published>
    <updated>2023-09-21T02:22:58.660Z</updated>
    
    <content type="html"><![CDATA[<p>3## Introduction to streams</p><p>Abstractly, a <strong>stream</strong> is a sequence of bytes that canbe accessed sequentially. Over time, a stream may produce or consumepotentially unlimited amounts of data. You can imagine stream to be a<strong>character buffer</strong> that automatically interacts with theexternal source. Streams automatically convert variables to a stringform that can be written into a buffer. And the opposite is a similarcase. A string stream is not connected to any external source.</p><h2 id="standard-streams">Standard streams</h2><ul><li><code>cin</code>: an <code>istream</code> object tied to thestandard input (typically the keyboard)</li><li><code>cout</code>: an <code>ostream</code> object tied to thestandard output (typically the monitor)</li><li><code>cerr</code>: an <code>ostream</code> object tied to thestandard error (typically the monitor), providing unbuffered output</li><li><code>clog</code>: an <code>ostream</code> object tied to thestandard error (typically the monitor), providing buffered output</li></ul><h2 id="output-streams">Output streams</h2><p>After you initializing an stream (empty, or initialized with a<code>const char*</code> or something else), the position starts at thebeginning of the "buffer". But after your stream insertion, the positionstarts at the end. Here is an example with the<code>std::ostringstream</code> :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// for cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  <span class="comment">// for ostringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ostringstream is a stream that writes to a string</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostringstream <span class="title">oss1</span><span class="params">(<span class="string">&quot; Hello world. &quot;</span>)</span></span>; <span class="comment">// initialize with string</span></span><br><span class="line">    std::cout &lt;&lt; oss1.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss2; <span class="comment">// initialize with no string</span></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; Nice 2 meet u. &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; See u tomorrow. &quot;</span> &lt;&lt; std::endl; <span class="comment">// append a string</span></span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world.</span><br><span class="line">Nice 2 meet u.</span><br><span class="line">Nice 2 meet u. See u tomorrow.</span><br></pre></td></tr></table></figure><h2 id="input-streams">Input streams</h2><p>Now we want to know the behavior of input streams. Take the<code>std::istringstream</code> as an example.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice to meet u 2. &quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="type">double</span> number;</span><br><span class="line"></span><br><span class="line">    iss &gt;&gt; word &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;word: &quot;</span> &lt;&lt; word &lt;&lt; std::endl; <span class="comment">// &quot;word: Nice&quot;</span></span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl; <span class="comment">// &quot;number: ?&quot;</span></span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 0</span><br></pre></td></tr></table></figure><p>In the example above, the variables read something from the<code>std::istringstream</code>. But clearly the <em>number</em> failedto read the value expected. Now we modify the <em>iss</em> a little.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice 2 meet u too. &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>And now the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 2</span><br></pre></td></tr></table></figure><h2 id="locate-and-set-the-position">Locate and set the position</h2><p>We use the method <code>tellp()</code> to get the position,<code>std::stream()</code> to create offset, and the<code>seekp()</code> to set a new position in the stream <code>ss</code>in the example below. These methods let you to manually set theposition, and most useful is the offset can be <strong>added</strong> topositions. But remember that <strong>the position can never be less than0</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    std::fpos pos = ss.<span class="built_in">tellp</span>() + std::<span class="built_in">streamoff</span>(<span class="number">3</span>); <span class="comment">// get position, and add 3</span></span><br><span class="line">    ss.<span class="built_in">seekp</span>(pos); <span class="comment">// set position</span></span><br></pre></td></tr></table></figure><h2 id="state-bits">State bits</h2><p>There four bits to indicate the state of the stream.</p><ol type="1"><li><code>Good bit</code>: Ready for read/write. Nothing unusual, onwhen <strong>other bits are off</strong>.</li><li><code>Fail bit</code>: Previous operation failed, all futureoperations <strong>frozen</strong>. Like:<ul><li>Type mismatch</li><li>File can't be opened</li><li>Seeking failed</li></ul></li><li><code>EOF bit</code>: Previous operation reached the end of thebuffer content. Nothing left.</li><li><code>Bad bit</code>: External error, likely irrecoverable. Couldnot move characters from external source (e.g. the file you are readingfrom is suddenly deleted).</li></ol><p><strong>Caution !!!</strong> - <code>Good</code> and<code>Fail</code> are not opposite, and <code>Good</code> and<code>Bad</code> are not opposite. - <code>Fail</code> and<code>EOF</code> are normally you will be checking. - You will rarelyuse <code>Good</code>.</p><p>Here is a function <code>printStreamState</code> to print the statebits of a stream.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStreamState</span><span class="params">(std::ostream &amp; os)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;good: &quot;</span> &lt;&lt; os.<span class="built_in">good</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail: &quot;</span> &lt;&lt; os.<span class="built_in">fail</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eof: &quot;</span> &lt;&lt; os.<span class="built_in">eof</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bad: &quot;</span> &lt;&lt; os.<span class="built_in">bad</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As a result, we can implement a complete version of the function<code>stringToInteger</code> with <strong>error-checking</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInteger</span><span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="comment">//passing by reference and never change it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">iss &gt;&gt; result;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> remain;</span><br><span class="line">iss &gt;&gt; remain;</span><br><span class="line"><span class="keyword">if</span> (!iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//make sure no characters left in the buffer</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, the <code>&gt;&gt;</code> operator returns the stream whichis converted to <code>!stream.fail()</code>. So we can have a veryhelpful shortcut from it:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iss &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) &#123; <span class="comment">//report error&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; ch)) &#123; <span class="comment">//report error&#125;</span></span><br></pre></td></tr></table></figure><p>So the error-checking part in the function<code>stringToInteger</code> can be rewriten as:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; result) || iss &gt;&gt; remain) </span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3## Introduction to streams&lt;/p&gt;
&lt;p&gt;Abstractly, a &lt;strong&gt;stream&lt;/strong&gt; is a sequence of bytes that can
be accessed sequentially. Over</summary>
      
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
</feed>
