<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shio</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-27T10:39:57.760Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chenyang Wan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Handbook</title>
    <link href="http://example.com/2023/09/25/Python%20Handbook/"/>
    <id>http://example.com/2023/09/25/Python%20Handbook/</id>
    <published>2023-09-25T13:47:36.345Z</published>
    <updated>2023-09-27T10:39:57.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h2><ul><li>将一个txt文件中的矩阵读出&#x2F;将一个矩阵写入txt文件中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_to_matrix</span>(<span class="params">path</span>):</span><br><span class="line">    mat = np.loadtxt(path, dtype=np.int32, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    mat = np.array(mat, dtype=np.uint8)</span><br><span class="line">    <span class="keyword">return</span> mat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_to_file</span>(<span class="params">mat, path</span>):</span><br><span class="line">    np.savetxt(path, np.c_[mat], fmt=<span class="string">&#x27;%d&#x27;</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><ul><li>将矩阵展开成为一维数组。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat = mat.ravel() <span class="comment">#横向</span></span><br><span class="line"></span><br><span class="line">mat = mat.ravel(order=<span class="string">&#x27;F&#x27;</span>) <span class="comment">#纵向</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;File-I-O&quot;&gt;&lt;a href=&quot;#File-I-O&quot; class=&quot;headerlink&quot; title=&quot;File I&amp;#x2F;O&quot;&gt;&lt;/a&gt;File I&amp;#x2F;O&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将一个txt文件中的矩阵读出&amp;#x2F;将一个矩阵写入txt文件中。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;file_to_matrix&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;path&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat = np.loadtxt(path, dtype=np.int32, delimiter=&lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat = np.array(mat, dtype=np.uint8)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;matrix_to_file&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;mat, path&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    np.savetxt(path, np.c_[mat], fmt=&lt;span class=&quot;string&quot;&gt;&amp;#x27;%d&amp;#x27;&lt;/span&gt;, delimiter=&lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Matrix&quot;&gt;&lt;a href=&quot;#Matrix&quot; class=&quot;headerlink&quot; title=&quot;Matrix&quot;&gt;&lt;/a&gt;Matrix&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将矩阵展开成为一维数组。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mat = mat.ravel() &lt;span class=&quot;comment&quot;&gt;#横向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mat = mat.ravel(order=&lt;span class=&quot;string&quot;&gt;&amp;#x27;F&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;#纵向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Articulated Robots: Lec1 Introduction</title>
    <link href="http://example.com/2023/09/24/Articulated%20Robots%20Lec1/"/>
    <id>http://example.com/2023/09/24/Articulated%20Robots%20Lec1/</id>
    <published>2023-09-24T07:19:58.405Z</published>
    <updated>2023-09-27T10:41:19.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul><li><strong>Mechanism</strong>: a system of two or more linked machine parts with kinetic parts.<ul><li>serially-connected open chain&#x2F;close chain</li></ul></li><li><strong>Kinetic pairs</strong>: the moveable contact between two linked machine pairs (Spot, Line, Surface).<ul><li>by pressure of contacts: <ul><li>lower pairs - surface</li><li>higher pairs - spot and line</li></ul></li></ul></li></ul><p><strong>Notion: most pairs in a robot are planar pairs.</strong></p><h2 id="Degree-of-Freedom"><a href="#Degree-of-Freedom" class="headerlink" title="Degree of Freedom"></a>Degree of Freedom</h2><ul><li>a particle: $DoF&#x3D;3$</li><li>a rigid body: $DoF&#x3D;6$</li><li>a robot: $DoF$ depends…</li></ul><h3 id="DoF-of-Planar-Mechanisms"><a href="#DoF-of-Planar-Mechanisms" class="headerlink" title="DoF of Planar Mechanisms"></a>DoF of Planar Mechanisms</h3><p>No. of movable parts: $n&#x3D;N-1$ (N is the number of pairs)<br>No. of lower pairs: $L$ (brings $2L$ constraints)<br>No. of higher pairs: $H$ (brings $H$ constraints)</p><p>total $DoF$: $3n-2L-H$</p><h2 id="Robot-Manipulators"><a href="#Robot-Manipulators" class="headerlink" title="Robot Manipulators"></a>Robot Manipulators</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mechanism&lt;/strong&gt;: a system of two or more linked machine parts with kinetic parts.&lt;ul&gt;
&lt;li&gt;serially-connected open chain&amp;#x2F;close chain&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kinetic pairs&lt;/strong&gt;: the moveable contact between two linked machine pairs (Spot, Line, Surface).&lt;ul&gt;
&lt;li&gt;by pressure of contacts: &lt;ul&gt;
&lt;li&gt;lower pairs - surface&lt;/li&gt;
&lt;li&gt;higher pairs - spot and line&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Notion: most pairs in a robot are planar pairs.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Degree-of-Freedom&quot;&gt;&lt;a href=&quot;#Degree-of-Freedom&quot; class=&quot;headerlink&quot; title=&quot;Degree of Freedom&quot;&gt;&lt;/a&gt;Degree of Freedom&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;a particle: $DoF&amp;#x3D;3$&lt;/li&gt;
&lt;li&gt;a rigid body: $DoF&amp;#x3D;6$&lt;/li&gt;
&lt;li&gt;a robot: $DoF$ depends…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;DoF-of-Planar-Mechanisms&quot;&gt;&lt;a href=&quot;#DoF-of-Planar-Mechanisms&quot; class=&quot;headerlink&quot; title=&quot;DoF of Planar Mechanisms&quot;&gt;&lt;/a&gt;DoF of Planar Mechanisms&lt;/h3&gt;&lt;p&gt;No. of movable parts: $n&amp;#x3D;N-1$ (N is the number of pairs)&lt;br&gt;No. of lower pairs: $L$ (brings $2L$ constraints)&lt;br&gt;No. of higher pairs: $H$ (brings $H$ constraints)&lt;/p&gt;
&lt;p&gt;total $DoF$: $3n-2L-H$&lt;/p&gt;
&lt;h2 id=&quot;Robot-Manipulators&quot;&gt;&lt;a href=&quot;#Robot-Manipulators&quot; class=&quot;headerlink&quot; title=&quot;Robot Manipulators&quot;&gt;&lt;/a&gt;Robot Manipulators&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>z变换</title>
    <link href="http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/"/>
    <id>http://example.com/2023/09/20/z%E5%8F%98%E6%8D%A2/</id>
    <published>2023-09-20T08:29:31.493Z</published>
    <updated>2023-09-26T00:41:03.118Z</updated>
    
    <content type="html"><![CDATA[<p>$z$变换（$ZT$）<strong>是对离散序列进行的一种数学变换</strong>，常用于求线性时不变差分方程的解，它在离散系统中的地位如同拉普拉斯变换在连续系统中的地位。在自动控制系统中引入$z$变换的主要目的是希望方便对于离散控制系统的研究。</p><h2 id="z-变换"><a href="#z-变换" class="headerlink" title="$z$变换"></a>$z$变换</h2><h3 id="z-变换的定义"><a href="#z-变换的定义" class="headerlink" title="$z$变换的定义"></a>$z$变换的定义</h3><p>设连续函数$e(t)$是可拉氏变换的，则其拉氏变换定义为：<br>$$<br>    E(s)&#x3D;\mathscr{L}\left[ e(t) \right]&#x3D;\int_{0}^{\infty}e(t)e^{-sT}dt<br>$$<br>对$e(t)$的采样后的信号的表达式为：<br>$$<br>e^*(t)&#x3D;\sum_0^\infty e(nT)\delta(t-nT)<br>$$<br>采样信号$e^*(t)$的拉氏变换为：</p><p>$$<br>E^*(s)&#x3D;\mathscr{L}[e^*(t)]&#x3D;\sum_0^\infty e(nT)e^{-nsT}<br>$$<br>可以看到在$s$域中的结果是比较复杂的，所以为了方便起见我们定义$z&#x3D;e^{sT}$，$T$为采样周期，$z$是在复数平面上定义的一个复变量，称为$z$为变换算子。</p><p>采样信号$e^*(t)$的$z$变换为：<br>$$<br>E(z)&#x3D;\mathscr{Z}[e^*(t)]&#x3D;\sum_0^\infty e(nT)e^{-snT} |_{s&#x3D;\frac{1}{T}lnz}&#x3D;\sum_0^\infty e(nT)z^{-n}<br>$$<br>这个结果的形式是很简单的，实际上就是采样所得函数在每个采样点$t&#x3D;nT$时候的值乘上$z^{-n}$，所以这个序列实际上表达出了每个特定的时刻的原函数取值。</p><h3 id="求-z-变换的方法"><a href="#求-z-变换的方法" class="headerlink" title="求$z$变换的方法"></a>求$z$变换的方法</h3><ol><li><p>级数求和<br>根据定义求$z$变换：<br>$$<br>F(z)&#x3D;\mathscr{Z}[f^*(t)]&#x3D;\sum_0^\infty f(nT)e^{-snT} |_{s&#x3D;\frac{1}{T}lnz}&#x3D;\sum_0^\infty f(nT)z^{-n}<br>$$<br>我们对于连续信号$f(t)$只需要将其在采样时间$t&#x3D;nT$的时候的取值与对应的$z^{-n}$相乘然后求和即可。</p></li><li><p>部分分式展开<br>这种方法主要用于对$F(s)$进行变换。也就是说先求出已知的连续时间函数$f(x)$的拉氏变换$F(s)$，再把这个拉氏变换的结果展开成部分分式之和的形式，使得每一个部分对应的分式能够对应简单的时间函数。然后可得对应部分分式之和的$z$变换结果。</p></li></ol><p>注意：$F(z)&#x3D;\mathscr{Z}[f^*(t)] \neq  \mathscr{Z}[f(t)]$</p><p>对于拉氏变换的结果$F(s)$，将其写为有理函数的形式：<br>$$<br>                F(s)&#x3D;\frac{P(s)}{Q(s)}&#x3D;\frac{\sum_{i&#x3D;0}^n(s-s_i)^r}{\sum_{j&#x3D;0}^m(s-s_j)^r}&#x3D;<br>$$<br>从而可以得到</p><ol start="3"><li>留数法</li></ol><ul><li>$f(t)$的$Laplace$变换是一个有理分式，$p_i$为其极点</li><li>$F(s)$分母的阶次比分子的阶次高2阶以上</li></ul><p>此时$z$变换的闭合解析形式表示为：$F(z)&#x3D;\hat{F}(z)+\beta$<br>其中：<br>$$<br>    \hat F(z)&#x3D;\sum_{i&#x3D;1}^{n}Res[F(p_i)\frac{1}{1-e^{-(s-p_i)T}}]<br>$$<br>$$<br>\beta &#x3D; \lim_{s \rightarrow \infty}sF(s) - \lim_{z \rightarrow \infty}\hat F(z)<br>$$<br>$\beta$的引入是为了保证初值相同。</p><h3 id="z-变换的性质"><a href="#z-变换的性质" class="headerlink" title="$z$变换的性质"></a>$z$变换的性质</h3><ol><li><p>线性性质</p></li><li><p>初值定理<br> 若$\lim_{z \rightarrow  \infty} F(z)$存在，则：<br> $$<br> \lim_{k \rightarrow 0}f(kT)  &#x3D; \lim_{z \rightarrow \infty}F(z)<br> $$</p></li><li><p>终值定理<br> 如果$F(z)$满足下列条件之一：</p><ol><li>$F(z)$ 的所有极点在开单位圆内</li><li>$F(z)$至多只有一个在单位圆上的极点，且必须为1处的一阶极点<br> 那么：<br> $$<br> \lim_{k \rightarrow \infty}f(kT)  &#x3D; \lim_{z \rightarrow 1}[(1-z^{-1})F(z)]<br> $$</li></ol></li><li><p>复域微分定理<br>$$<br>\mathscr Z [tx(t)] &#x3D; -Tz \frac{dX(z)}{dz}<br>$$<br>$$<br>\mathscr Z [kx(t)] &#x3D; -z \frac{dX(z)}{dz} \quad where \quad k &#x3D; \frac{t}{T}<br>$$</p></li><li><p>复位移定理<br>$$<br> \mathscr Z[e^{-\alpha T}x(t)]&#x3D;<br>$$</p></li></ol><h2 id="z-反变换"><a href="#z-反变换" class="headerlink" title="$z$反变换"></a>$z$反变换</h2><ul><li>相同的$z$变换$E(z)$对应于相同的采样函数$e^*(t)$，但是不一定对应于相同的原连续函数$e(t)$。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;$z$变换（$ZT$）&lt;strong&gt;是对离散序列进行的一种数学变换&lt;/strong&gt;，常用于求线性时不变差分方程的解，它在离散系统中的地位如同拉普拉斯变换在连续系统中的地位。在自动控制系统中引入$z$变换的主要目的是希望方便对于离散控制系统的研究。&lt;/p&gt;
&lt;h2 id=&quot;z-变换&quot;&gt;&lt;a href=&quot;#z-变换&quot; class=&quot;headerlink&quot; title=&quot;$z$变换&quot;&gt;&lt;/a&gt;$z$变换&lt;/h2&gt;&lt;h3 id=&quot;z-变换的定义&quot;&gt;&lt;a href=&quot;#z-变换的定义&quot; class=&quot;headerlink&quot; title=&quot;$z$变换的定义&quot;&gt;&lt;/a&gt;$z$变换的定义&lt;/h3&gt;&lt;p&gt;设连续函数$e(t)$是可拉氏变换的，则其拉氏变换定义为：&lt;br&gt;$$&lt;br&gt;    E(s)&amp;#x3D;&#92;mathscr{L}&#92;left[ e(t) &#92;right]&amp;#x3D;&#92;int_{0}^{&#92;infty}e(t)e^{-sT}dt&lt;br&gt;$$&lt;br&gt;对$e(t)$的采样后的信号的表达式为：&lt;br&gt;$$&lt;br&gt;e^*(t)&amp;#x3D;&#92;sum_0^&#92;infty e(nT)&#92;delta(t-nT)&lt;br&gt;$$&lt;br&gt;采样信号$e^*(t)$的拉氏变换为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;E^*(s)&amp;#x3D;&#92;mathscr{L}[e^*(t)]&amp;#x3D;&#92;sum_0^&#92;infty e(nT)e^{-nsT}&lt;br&gt;$$&lt;br&gt;可以看到在$s$域中的结果是比较复杂的，所以为了方便起见我们定义$z&amp;#x3D;e^{sT}$，$T$为采样周期，$z$是在复数平面上定义的一个复变量，称为$z$为变换算子。&lt;/p&gt;
&lt;p&gt;采样信号$e^*(t)$的$z$变换为：&lt;br&gt;$$&lt;br&gt;E(z)&amp;#x3D;&#92;mathscr{Z}[e^*(t)]&amp;#x3D;&#92;sum_0^&#92;infty e(nT)e^{-snT} |_{s&amp;#x3D;&#92;frac{1}{T}lnz}&amp;#x3D;&#92;sum_0^&#92;infty e(nT)z^{-n}&lt;br&gt;$$&lt;br&gt;这个结果的形式是很简单的，实际上就是采样所得函数在每个采样点$t&amp;#x3D;nT$时候的值乘上$z^{-n}$，所以这个序列实际上表达出了每个特定的时刻的原函数取值。&lt;/p&gt;
&lt;h3 id=&quot;求-z-变换的方法&quot;&gt;&lt;a href=&quot;#求-z-变换的方法&quot; class=&quot;headerlink&quot; title=&quot;求$z$变换的方法&quot;&gt;&lt;/a&gt;求$z$变换的方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;级数求和&lt;br&gt;根据定义求$z$变换：&lt;br&gt;$$&lt;br&gt;F(z)&amp;#x3D;&#92;mathscr{Z}[f^*(t)]&amp;#x3D;&#92;sum_0^&#92;infty f(nT)e^{-snT} |_{s&amp;#x3D;&#92;frac{1}{T}lnz}&amp;#x3D;&#92;sum_0^&#92;infty f(nT)z^{-n}&lt;br&gt;$$&lt;br&gt;我们对于连续信号$f(t)$只需要将其在采样时间$t&amp;#x3D;nT$的时候的取值与对应的$z^{-n}$相乘然后求和即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部分分式展开&lt;br&gt;这种方法主要用于对$F(s)$进行变换。也就是说先求出已知的连续时间函数$f(x)$的拉氏变换$F(s)$，再把这个拉氏变换的结果展开成部分分式之和的形式，使得每一个部分对应的分式能够对应简单的时间函数。然后可得对应部分分式之和的$z$变换结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：$F(z)&amp;#x3D;&#92;mathscr{Z}[f^*(t)] &#92;neq  &#92;mathscr{Z}[f(t)]$&lt;/p&gt;
&lt;p&gt;对于拉氏变换的结果$F(s)$，将其写为有理函数的形式：&lt;br&gt;$$&lt;br&gt;                F(s)&amp;#x3D;&#92;frac{P(s)}{Q(s)}&amp;#x3D;&#92;frac{&#92;sum_{i&amp;#x3D;0}^n(s-s_i)^r}{&#92;sum_{j&amp;#x3D;0}^m(s-s_j)^r}&amp;#x3D;&lt;br&gt;$$&lt;br&gt;从而可以得到&lt;/p&gt;</summary>
    
    
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec2 Stream II</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec2%20Stream%20II/</id>
    <published>2023-09-19T07:40:26.838Z</published>
    <updated>2023-09-19T07:41:26.636Z</updated>
    
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec0 Intro</title>
    <link href="http://example.com/2023/09/19/CS106L%20Lec0%20Intro/"/>
    <id>http://example.com/2023/09/19/CS106L%20Lec0%20Intro/</id>
    <published>2023-09-19T05:08:57.367Z</published>
    <updated>2023-09-23T06:41:46.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Types-and-Structs"><a href="#C-Types-and-Structs" class="headerlink" title="C++ Types and Structs"></a>C++ Types and Structs</h2><h3 id="Fundamental-Types"><a href="#Fundamental-Types" class="headerlink" title="Fundamental Types"></a>Fundamental Types</h3><h3 id="Dynamic-and-Static-typing"><a href="#Dynamic-and-Static-typing" class="headerlink" title="Dynamic and Static typing"></a>Dynamic and Static typing</h3><p>C++ is a <strong>statically typed language.</strong></p><ul><li><code>statically typed</code>: Everything with a name (variables, functions, etc) is <strong>given a type before runtime.</strong> (C++)</li><li><code>dynamically typed</code>: Everything with a name (variables, functions, etc) is <strong>given a type at runtime</strong> based on the thing’s current value. (Python)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CRASH during runtime, can’t divide a string</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_3</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">div_3(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile error: this code will never run</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div_3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">div_3</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Runtime</code>: Period when program is executing commands (after compilation, if compiled).</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;C-Types-and-Structs&quot;&gt;&lt;a href=&quot;#C-Types-and-Structs&quot; class=&quot;headerlink&quot; title=&quot;C++ Types and Structs&quot;&gt;&lt;/a&gt;C++ Types and Structs&lt;/h2&gt;&lt;h3 id=&quot;Fundamental-Types&quot;&gt;&lt;a href=&quot;#Fundamental-Types&quot; class=&quot;headerlink&quot; title=&quot;Fundamental Types&quot;&gt;&lt;/a&gt;Fundamental Types&lt;/h3&gt;&lt;h3 id=&quot;Dynamic-and-Static-typing&quot;&gt;&lt;a href=&quot;#Dynamic-and-Static-typing&quot; class=&quot;headerlink&quot; title=&quot;Dynamic and Static typing&quot;&gt;&lt;/a&gt;Dynamic and Static typing&lt;/h3&gt;&lt;p&gt;C++ is a &lt;strong&gt;statically typed language.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;statically typed&lt;/code&gt;: Everything with a name (variables, functions, etc) is &lt;strong&gt;given a type before runtime.&lt;/strong&gt; (C++)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamically typed&lt;/code&gt;: Everything with a name (variables, functions, etc) is &lt;strong&gt;given a type at runtime&lt;/strong&gt; based on the thing’s current value. (Python)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# CRASH during runtime, can’t divide a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;div_3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;div_3(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Compile error: this code will never run&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;div_3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;div_3&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;: Period when program is executing commands (after compilation, if compiled).&lt;/p&gt;
</summary>
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: ROS</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20ROS/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20ROS/</id>
    <published>2023-09-19T05:03:43.497Z</published>
    <updated>2023-09-19T05:10:56.652Z</updated>
    
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="ROS" scheme="http://example.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Debug list: Linux</title>
    <link href="http://example.com/2023/09/19/Debug%20list%20Linux/"/>
    <id>http://example.com/2023/09/19/Debug%20list%20Linux/</id>
    <published>2023-09-19T05:00:34.120Z</published>
    <updated>2023-09-19T05:10:42.512Z</updated>
    
    
    
    
    
    <category term="Debug" scheme="http://example.com/tags/Debug/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CS229: Lec1 Supervised Learning</title>
    <link href="http://example.com/2023/09/19/CS229%20Lec1/"/>
    <id>http://example.com/2023/09/19/CS229%20Lec1/</id>
    <published>2023-09-19T01:53:29.923Z</published>
    <updated>2023-09-19T05:10:29.943Z</updated>
    
    
    
    
    
    <category term="MachineLearning" scheme="http://example.com/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>CS106L: Lec1 Stream I</title>
    <link href="http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/"/>
    <id>http://example.com/2023/09/18/CS106L%20Lec1%20Stream%20I/</id>
    <published>2023-09-18T12:08:45.236Z</published>
    <updated>2023-09-21T02:22:58.660Z</updated>
    
    <content type="html"><![CDATA[<p>3## Introduction to streams</p><p>Abstractly, a <strong>stream</strong> is a sequence of bytes that can be accessed sequentially. Over time, a stream may produce or consume potentially unlimited amounts of data. You can imagine stream to be a <strong>character buffer</strong> that automatically interacts with the external source. Streams automatically convert variables to a string form that can be written into a buffer.  And the opposite is a similar case. A string stream is not connected to any external source. </p><h2 id="Standard-streams"><a href="#Standard-streams" class="headerlink" title="Standard streams"></a>Standard streams</h2><ul><li><code>cin</code>: an <code>istream</code> object tied to the standard input (typically the keyboard)</li><li><code>cout</code>: an <code>ostream</code> object tied to the standard output (typically the monitor)</li><li><code>cerr</code>: an <code>ostream</code> object tied to the standard error (typically the monitor), providing unbuffered output</li><li><code>clog</code>: an <code>ostream</code> object tied to the standard error (typically the monitor), providing buffered output</li></ul><h2 id="Output-streams"><a href="#Output-streams" class="headerlink" title="Output streams"></a>Output streams</h2><p>After you initializing an stream (empty, or initialized with a <code>const char*</code> or something else), the position starts at the beginning of the “buffer”. But after your stream insertion, the position starts at the end. Here is an example with the <code>std::ostringstream</code> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// for cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  <span class="comment">// for ostringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ostringstream is a stream that writes to a string</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostringstream <span class="title">oss1</span><span class="params">(<span class="string">&quot; Hello world. &quot;</span>)</span></span>; <span class="comment">// initialize with string</span></span><br><span class="line">    std::cout &lt;&lt; oss1.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss2; <span class="comment">// initialize with no string</span></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; Nice 2 meet u. &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    oss2 &lt;&lt; <span class="string">&quot; See u tomorrow. &quot;</span> &lt;&lt; std::endl; <span class="comment">// append a string</span></span><br><span class="line">    std::cout &lt;&lt; oss2.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world.</span><br><span class="line">Nice 2 meet u.</span><br><span class="line">Nice 2 meet u. See u tomorrow.</span><br></pre></td></tr></table></figure><h2 id="Input-streams"><a href="#Input-streams" class="headerlink" title="Input streams"></a>Input streams</h2><p>Now we want to know the behavior of input streams. Take the <code>std::istringstream</code> as an example. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice to meet u 2. &quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="type">double</span> number;</span><br><span class="line"></span><br><span class="line">    iss &gt;&gt; word &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;word: &quot;</span> &lt;&lt; word &lt;&lt; std::endl; <span class="comment">// &quot;word: Nice&quot;</span></span><br><span class="line">    std::cout &lt;&lt; iss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl; <span class="comment">// &quot;number: ?&quot;</span></span><br></pre></td></tr></table></figure><p>And the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 0</span><br></pre></td></tr></table></figure><p>In the example above, the variables read something from the <code>std::istringstream</code>. But clearly the <em>number</em> failed to read the value expected. Now we modify the <em>iss</em> a little.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot; Nice 2 meet u too. &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>And now the output is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Nice to meet u 2.</span><br><span class="line">word: Nice</span><br><span class="line"> Nice to meet u 2.</span><br><span class="line">number: 2</span><br></pre></td></tr></table></figure><h2 id="Locate-and-set-the-position"><a href="#Locate-and-set-the-position" class="headerlink" title="Locate and set the position"></a>Locate and set the position</h2><p>We use the method <code>tellp()</code> to get the position, <code>std::stream()</code> to create offset, and the <code>seekp()</code> to set a new position in the stream <code>ss</code> in the example below. These methods let you to manually set the position, and most useful is the offset can be <strong>added</strong> to positions. But remember that <strong>the position can never be less than 0</strong>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    std::fpos pos = ss.<span class="built_in">tellp</span>() + std::<span class="built_in">streamoff</span>(<span class="number">3</span>); <span class="comment">// get position, and add 3</span></span><br><span class="line">    ss.<span class="built_in">seekp</span>(pos); <span class="comment">// set position</span></span><br></pre></td></tr></table></figure><h2 id="State-bits"><a href="#State-bits" class="headerlink" title="State bits"></a>State bits</h2><p>There four bits to indicate the state of the stream.</p><ol><li><code>Good bit</code>: Ready for read&#x2F;write. Nothing unusual, on when <strong>other bits are off</strong>.</li><li><code>Fail bit</code>: Previous operation failed, all future operations <strong>frozen</strong>. Like: <ul><li>Type mismatch</li><li>File can’t be opened</li><li>Seeking failed</li></ul></li><li><code>EOF bit</code>: Previous operation reached the end of the buffer content. Nothing left.</li><li><code>Bad bit</code>: External error, likely irrecoverable. Could not move characters from external source (e.g. the file you are reading from is suddenly deleted).</li></ol><p><strong>Caution !!!</strong></p><ul><li><code>Good</code> and <code>Fail</code> are not opposite, and <code>Good</code> and <code>Bad</code> are not opposite. </li><li><code>Fail</code> and <code>EOF</code> are normally you will be checking. </li><li>You will rarely use <code>Good</code>.</li></ul><p>Here is a function <code>printStreamState</code> to print the state bits of a stream.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStreamState</span><span class="params">(std::ostream &amp; os)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;good: &quot;</span> &lt;&lt; os.<span class="built_in">good</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail: &quot;</span> &lt;&lt; os.<span class="built_in">fail</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eof: &quot;</span> &lt;&lt; os.<span class="built_in">eof</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bad: &quot;</span> &lt;&lt; os.<span class="built_in">bad</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As a result, we can implement a complete version of the function <code>stringToInteger</code> with <strong>error-checking</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInteger</span><span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="comment">//passing by reference and never change it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">iss &gt;&gt; result;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> remain;</span><br><span class="line">iss &gt;&gt; remain;</span><br><span class="line"><span class="keyword">if</span> (!iss.<span class="built_in">fail</span>()) <span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//make sure no characters left in the buffer</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, the <code>&gt;&gt;</code> operator returns the stream which is converted to <code>!stream.fail()</code>. So we can have a very helpful shortcut from it: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iss &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) &#123; <span class="comment">//report error&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; ch)) &#123; <span class="comment">//report error&#125;</span></span><br></pre></td></tr></table></figure><p>So the error-checking part in the function <code>stringToInteger</code> can be rewriten as:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; result) || iss &gt;&gt; remain) </span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">domin_error</span>(...); <span class="comment">//read an integer from the buffer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;3## Introduction to streams&lt;/p&gt;
&lt;p&gt;Abstractly, a &lt;strong&gt;stream&lt;/strong&gt; is a sequence of bytes that can be accessed sequentially. Over time, a stream may produce or consume potentially unlimited amounts of data. You can imagine stream to be a &lt;strong&gt;character buffer&lt;/strong&gt; that automatically interacts with the external source. Streams automatically convert variables to a string form that can be written into a buffer.  And the opposite is a similar case. A string stream is not connected to any external source. &lt;/p&gt;
&lt;h2 id=&quot;Standard-streams&quot;&gt;&lt;a href=&quot;#Standard-streams&quot; class=&quot;headerlink&quot; title=&quot;Standard streams&quot;&gt;&lt;/a&gt;Standard streams&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cin&lt;/code&gt;: an &lt;code&gt;istream&lt;/code&gt; object tied to the standard input (typically the keyboard)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the standard output (typically the monitor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the standard error (typically the monitor), providing unbuffered output&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;: an &lt;code&gt;ostream&lt;/code&gt; object tied to the standard error (typically the monitor), providing buffered output&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Output-streams&quot;&gt;&lt;a href=&quot;#Output-streams&quot; class=&quot;headerlink&quot; title=&quot;Output streams&quot;&gt;&lt;/a&gt;Output streams&lt;/h2&gt;&lt;p&gt;After you initializing an stream (empty, or initialized with a &lt;code&gt;const char*&lt;/code&gt; or something else), the position starts at the beginning of the “buffer”. But after your stream insertion, the position starts at the end. Here is an example with the &lt;code&gt;std::ostringstream&lt;/code&gt; : &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// for cout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;sstream&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// for ostringstream&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ostringstream is a stream that writes to a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;std::ostringstream &lt;span class=&quot;title&quot;&gt;oss1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot; Hello world. &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// initialize with string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss1.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::ostringstream oss2; &lt;span class=&quot;comment&quot;&gt;// initialize with no string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oss2 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; Nice 2 meet u. &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss2.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oss2 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; See u tomorrow. &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;comment&quot;&gt;// append a string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; oss2.&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;And the output is:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Hello world.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nice 2 meet u.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nice 2 meet u. See u tomorrow.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Input-streams&quot;&gt;&lt;a href=&quot;#Input-streams&quot; class=&quot;headerlink&quot; title=&quot;Input streams&quot;&gt;&lt;/a&gt;Input streams&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
</feed>
